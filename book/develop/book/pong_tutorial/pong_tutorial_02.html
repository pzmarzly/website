<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Drawing the paddles - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./intro.html"><strong>1.</strong> Introduction</a></li><li><a href="./getting_started.html"><strong>2.</strong> Getting Started</a></li><li><a href="./simple_application.html"><strong>3.</strong> A Simple Application</a></li><li><a href="pong_tutorial.html"><strong>4.</strong> Pong Tutorial</a></li><li><ul class="section"><li><a href="./pong_tutorial/pong_tutorial_01.html"><strong>4.1.</strong> Opening (and closing!) a window</a></li><li><a href="./pong_tutorial/pong_tutorial_02.html" class="active"><strong>4.2.</strong> Drawing the paddles</a></li></ul></li><li><a href="./glossary.html"><strong>5.</strong> Glossary</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./pong_tutorial/pong_tutorial_02.html#drawing-the-paddles" id="drawing-the-paddles"><h1>Drawing the paddles</h1></a>
<p>Now let's do some drawing! But to draw something, we need something to draw. In
Amethyst, those &quot;somethings&quot; are called Entities, which are described by
Components.</p>
<p>Amethyst uses Specs for its ECS (Entity-component system), which is a parallel
Entity-component system written in Rust. You can learn more about Specs in the
<a href="https://slide-rs.github.io/specs-website/docs/book/master/">The Specs Book</a>. Here's a basic explanation of ECS from there:</p>
<blockquote>
<p>The term ECS is a shorthand for Entity-component system. These are the three
core concepts. Each entity is associated with some components. Those entities
and components are processed by systems. This way, you have your data
(components) completely separated from the behaviour (systems). An entity just
logically groups components; so a Velocity component can be applied to the
Position component of the same entity.</p>
</blockquote>
<p>I recommend at least skimming the rest of The Specs Book to get a good intuition
of how Amethyst works, especially if you're new to ECS.</p>
<a class="header" href="./pong_tutorial/pong_tutorial_02.html#a-quick-refactor" id="a-quick-refactor"><h2>A quick refactor</h2></a>
<p>Let's create a new file called <code>pong.rs</code> to hold our core game logic. We can
move the <code>Pong</code> struct over here, and the <code>impl State for Pong</code> block as well.
Then, in <code>main.rs</code> declare a module:</p>
<pre><code class="language-rust ignore">mod pong; 
</code></pre>
<p>And in the <code>run()</code> function add:</p>
<pre><code class="language-rust ignore">use pong::Pong;
</code></pre>
<p>Now you can just delete various <code>main.rs</code> use statements until the Rust compiler
stops complaining about unused imports. In <code>pong.rs</code> we'll need these use
statements to make it through this chapter:</p>
<pre><code class="language-rust ignore">use amethyst::prelude::*;
use amethyst::ecs::{Component, DenseVecStorage};
use amethyst::assets::Loader;
use amethyst::core::cgmath::Vector3;
use amethyst::core::transform::{LocalTransform, Transform};
use amethyst::renderer::{Camera, Material, MaterialDefaults, PosTex, MeshHandle, 
                         Event,KeyboardInput, VirtualKeyCode, WindowEvent};
</code></pre>
<a class="header" href="./pong_tutorial/pong_tutorial_02.html#our-first-component" id="our-first-component"><h2>Our first Component</h2></a>
<p>In <code>pong.rs</code> let's create our first <code>Component</code>, a definition of a paddle.</p>
<pre><code class="language-rust ignore">#[derive(PartialEq, Eq)]
enum Side {
    Left,
    Right,
}

struct Paddle {
    pub side: Side,
    pub width: f32,
    pub height: f32,
}

impl Paddle {
    fn new(side: Side) -&gt; Paddle {
        Paddle {
            side: side,
            width: 1.0,
            height: 1.0,
        }
    }
}
</code></pre>
<p>&quot;But that just looks like a regular struct!&quot; you might say. And you're right,
here's the special sauce:</p>
<pre><code class="language-rust ignore">impl Component for Paddle {
    type Storage = DenseVecStorage&lt;Self&gt;;
}
</code></pre>
<p>By implementing <code>Component</code> for our <code>Paddle</code> struct, and defining the way we'd
like that <code>Component</code> data stored, we can now add the <code>Paddle</code> component to
entities in our game. For more on storage types, check out the
<a href="https://slide-rs.github.io/specs-website/docs/book/master/05_storages.html#densevecstorage">Specs documentation</a>.</p>
<a class="header" href="./pong_tutorial/pong_tutorial_02.html#where-is-the-world" id="where-is-the-world"><h2>Where is the world?</h2></a>
<p>Now it's time to add a new method to our State implementation: <code>on_start</code>.
Inside this function, we'll <code>register</code> our <code>Paddle</code> component on the mutable
<code>World</code> object we're passed by Amethyst's state machine when the game starts up.</p>
<pre><code class="language-rust ignore">fn on_start(&amp;mut self, world: &amp;mut World) {
    world.register::&lt;Paddle&gt;();
}
</code></pre>
<p>This <code>World</code> gets passed around everywhere. It carries with it all the
components in our game. Not only the components we create, but the ones the
Amethyst engine itself relies on. For instance, in our <code>main.rs</code> we added a
<code>RenderBundle::new()</code> to our game before calling <code>run()</code>. That added default
rendering components like <code>Camera</code>, <code>Material</code>, and <code>Mesh</code> to the <code>World</code>, some
of which we'll be using soon.</p>
<a class="header" href="./pong_tutorial/pong_tutorial_02.html#initialise-some-entities" id="initialise-some-entities"><h2>Initialise some entities</h2></a>
<p>Now that we have a Paddle component, let's define some paddle entities that
include that component and add them to our <code>World</code>.</p>
<p>First let's look at our math imports:</p>
<pre><code class="language-rust ignore">use amethyst::core::cgmath::Vector3;
use amethyst::core::transform::{LocalTransform, Transform};
</code></pre>
<p>Amethyst uses the <a href="https://docs.rs/cgmath/0.15.0/cgmath/">cgmath crate</a> under the hood and exposes it for our use.
Today we just grabbed the <code>Vector3</code> type, which is a very good math thing to have.</p>
<p><code>LocalTransform</code> and <code>Transform</code> are Amethyst ECS components which carry
position and orientation information. <code>LocalTransform</code> is relative
to a parent if one exists, while <code>Transform</code> is global.</p>
<p>Let's also define some constants for convenience:</p>
<pre><code class="language-rust ignore">const PADDLE_HEIGHT: f32 = 0.30;
const PADDLE_WIDTH: f32 = 0.05;
const PADDLE_COLOUR: [f32; 4] = [0.0, 0.0, 1.0, 1.0];
</code></pre>
<p>Okay, let's make some entities! We'll define an <code>initialise_paddles</code> function
which will create left and right paddle entities and attach <code>LocalTransform</code>
components to them to position them in our world. Our canvas goes from
<code>-1.0,-1.0</code> on the bottom left to <code>1.0,1.0</code> on the top right, which will make
more sense when we define the camera.</p>
<pre><code class="language-rust ignore">/// Initialises one paddle on the left, and one paddle on the right.
fn initialise_paddles(world: &amp;mut World) {

    let mut left_transform = LocalTransform::default();
    let mut right_transform = LocalTransform::default();

    // Correctly position the paddles.
    let y = -PADDLE_HEIGHT / 2.0;
    left_transform.translation = Vector3::new(-1.0, y, 0.0);
    right_transform.translation = Vector3::new(1.0 - PADDLE_WIDTH, y, 0.0);

    // Create a left plank entity.
    world
        .create_entity()
        .with(Paddle::new(Side::Left))
        .with(Transform::default())
        .with(left_transform)
        .build();

    // Create right plank entity.
    world
        .create_entity()
        .with(Paddle::new(Side::Right))
        .with(Transform::default())
        .with(right_transform)
        .build();
}
</code></pre>
<p>This is all the information Amethyst needs to track and move the paddles in our
virtual world, but we'll need to do some more work to actually <em>draw</em> them.</p>
<a class="header" href="./pong_tutorial/pong_tutorial_02.html#drawing" id="drawing"><h2>Drawing</h2></a>
<p>Here's a utility function to generate the six vertices of a rectangle (a
rectangle in computer graphics is typically drawn with two triangles):</p>
<pre><code class="language-rust ignore">fn generate_rectangle_vertices(left: f32,
                               bottom: f32,
                               right: f32,
                               top: f32) -&gt; Vec&lt;PosTex&gt; {
    vec![
        PosTex {
            position: [left, bottom, 0.],
            tex_coord: [0.0, 0.0],
        },
        PosTex {
            position: [right, bottom, 0.0],
            tex_coord: [1.0, 0.0],
        },
        PosTex {
            position: [left, top, 0.0],
            tex_coord: [1.0, 1.0],
        },
        PosTex {
            position: [right, top, 0.],
            tex_coord: [1.0, 1.0],
        },
        PosTex {
            position: [left, top, 0.],
            tex_coord: [0.0, 1.0],
        },
        PosTex {
            position: [right, bottom, 0.0],
            tex_coord: [0.0, 0.0],
        },
    ]
}
</code></pre>
<p><code>PosTex</code> is a type defined by <code>amethyst_renderer</code>. It's a vertex format with
position and UV texture coordinate attributes. In our rendering pipeline, if
you'll recall, we created a <code>DrawFlat::&lt;PosTex&gt;</code> pass, which draws a <code>PosTex</code>
mesh. Right now our vertices are simply in a standard Rust <code>Vector</code>. To create a
mesh from them we'll write another utility function, which generates a
<code>MeshHandle</code>:</p>
<pre><code class="language-rust ignore">fn create_mesh(world: &amp;World, vertices: Vec&lt;PosTex&gt;) -&gt; MeshHandle {
    let loader = world.read_resource::&lt;Loader&gt;();
    loader.load_from_data(vertices.into(), (), &amp;world.read_resource())
}
</code></pre>
<p>The <code>Loader</code> is an asset loader which is defined as a <code>resource</code> (not a <code>Entity</code>
, <code>Component</code>, or <code>System</code>, but still a part of our ECS <code>world</code>). It was created
when we built our Application in <code>main.rs</code>, and it can read assets like .obj
files, but also it can <code>load_from_data</code> as in our use case.</p>
<blockquote>
<p>Resources in Specs are a type of data which can be shared between systems,
while being independent from entities, in contrast to components, which are
attached to specific entities. We'll explore this more later on.</p>
</blockquote>
<p>The <code>load_from_data</code> function returns a <code>Handle&lt;Mesh&gt;</code>, also known as a
<code>MeshHandle</code>. Since <code>Handle</code> implements component, we can attach it to our
entity. Once the mesh is fully loaded, a system which asks the handle for the
mesh will receive it. If the mesh isn't loaded yet, the handle will return
<code>None</code>. In this minimal scenario, the mesh will be available on the next
frame.</p>
<p>In addition to mesh data, we also need a material to draw our mesh with.
We'll use the Amethyst renderer's <code>MaterialDefaults</code> (another resource) and only
change the albedo color:</p>
<pre><code class="language-rust ignore">/// Creates a solid material of the specified colour.
fn create_colour_material(world: &amp;World, colour: [f32; 4]) -&gt; Material {
    let mat_defaults = world.read_resource::&lt;MaterialDefaults&gt;();
    let loader = world.read_resource::&lt;Loader&gt;();

    let albedo = loader.load_from_data(colour.into(),
                                       (),
                                       &amp;world.read_resource());

    Material {
        albedo,
        ..mat_defaults.0.clone()
    }
}
</code></pre>
<p>Now let's return to inside our <code>initialise_paddles</code> function and actually create
this mesh and material.</p>
<pre><code class="language-rust ignore">let mesh = create_mesh(
    world,
    generate_rectangle_vertices(0.0, 0.0, PADDLE_WIDTH, PADDLE_HEIGHT),
);

let material = create_colour_material(world, PADDLE_COLOUR);
</code></pre>
<p>Now we just add these components to our paddle entities:</p>
<pre><code class="language-rust ignore">// Create a left plank entity.
world
    .create_entity()
    .with(mesh.clone())
    .with(material.clone())
    .with(Paddle::new(Side::Left))
    .with(Transform::default())
    .with(left_transform)
    .build();

// Create right plank entity.
world
    .create_entity()
    .with(mesh)
    .with(material)
    .with(Paddle::new(Side::Right))
    .with(Transform::default())
    .with(right_transform)
    .build();
</code></pre>
<p>We're almost done! We just need to create a camera to view all our beautiful
graphics (two blue pong paddles) with.</p>
<pre><code class="language-rust ignore">fn initialise_camera(world: &amp;mut World) {
    world
        .create_entity()
        .with(Camera::standard_2d())
        .build();
}
</code></pre>
<p>The camera is another entity, with a <code>Camera</code> component. Amethyst's
<a href="https://www.amethyst.rs/doc/develop/doc/amethyst_renderer/struct.Camera.html#method.standard_2d"><code>standard_2d</code> camera</a> uses an orthographic projection, and defines a
screenspace coordinate system of <code>-1.0,-1.0</code> in the bottom left and <code>1.0,1.0</code> in
the top right.</p>
<p>If you want to to define your own coordinate system, you can use something like
this:</p>
<pre><code class="language-rust ignore">fn initialise_camera(world: &amp;mut World) {
    world.create_entity()
        .with(Camera::from(Projection::orthographic(0.0, WIDTH, HEIGHT, 0.0)))
        .with(Transform(Matrix4::from_translation
                (Vector3::new(0.0, 0.0, 1.0)).into())
             )
        .build();
}
</code></pre>
<p>To use that custom camera you'll need to define WIDTH and HEIGHT constants, and
redo the position math in the <code>initialise_paddles</code> function.</p>
<p>Now let's add our initialise functions to the <code>on_start</code> function in <code>impl State for Pong</code>.</p>
<pre><code class="language-rust ignore">fn on_start(&amp;mut self, world: &amp;mut World) {
    world.register::&lt;Paddle&gt;();
    initialise_paddles(world);
    initialise_camera(world);
}
</code></pre>
<p>Okay! We've defined our <code>Paddle</code> component, and created two entities which have
<code>Paddle</code>, <code>Transform</code>, <code>MeshHandle</code>, and <code>Material</code> components. When our game
starts, we'll register the <code>Paddle</code> component and then add the left and right
paddles to the world, along with a camera.</p>
<p>Let's run this and see what happens. On my machine I get a panic that reads:</p>
<pre><code>No component with the given id. Did you forget to register the component with 
`World::register::&lt;ComponentName&gt;()`?
</code></pre>
<p>It looks like we're missing at least one component registration. In addition to
components we define ourselves, Amethyst has a lot of internal systems and
components it uses to keep things running. For simplicity, these have been
wrapped up into &quot;Bundles&quot; which include related components, systems, and
resources. We can add these to our Application using the <code>with_bundle</code> method,
and in fact we already have one of these in <code>main.rs</code>: the <code>RenderBundle</code>.</p>
<p>As it turns out, the components we're missing are <code>Transform</code> and
<code>LocalTransform</code>, and we can add those with the <code>TransformBundle</code>, which will
also add the <code>TransformSystem</code> for working with those components:</p>
<pre><code class="language-rust ignore">let mut game = Application::build(&quot;./&quot;, Pong)?
    .with_bundle(TransformBundle::new())? //Add this bundle
    .with_bundle(RenderBundle::new())?
    .with_local(RenderSystem::build(pipe, Some(config))?)
    .build()?;
</code></pre>
<p>Also we'll need to import that structure:</p>
<pre><code class="language-rust ignore">use amethyst::core::transform::TransformBundle;
</code></pre>
<p>Now when we run the game we should get something that looks like this:</p>
<p><img src="./images/pong_tutorial/pong_02.png" alt="Step two" /></p>
<p>In the next chapter we'll explore the &quot;S&quot; in ECS and actually get these paddles
moving!</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./pong_tutorial/pong_tutorial_01.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./glossary.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./pong_tutorial/pong_tutorial_01.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./glossary.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
